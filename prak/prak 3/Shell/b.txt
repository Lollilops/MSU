     1	     1	     1	Получено: ls -l|cat -n 1.c
     2	     2	     2	Выполнение ls -l|cat -n 1.c
     3	     3	     3	     1	#include <stdio.h>
     4	     4	     4	     2	#include <stdlib.h>
     5	     5	     5	     3	#include <string.h>
     6	     6	     6	     4	#include <unistd.h>
     7	     7	     7	     5	#include <sys/wait.h>
     8	     8	     8	     6	#include <sys/types.h>
     9	     9	     9	     7	#include <sys/file.h>
    10	    10	    10	     8	
    11	    11	    11	     9	// ps; ls; (cd Shell_A; ls; ps) && ls && ps
    12	    12	    12	    10	// date; (ls -l|cat -n 1.c)>f & pwd
    13	    13	    13	    11	
    14	    14	    14	    12	char current_path[1000];
    15	    15	    15	    13	
    16	    16	    16	    14	int MayBeCD(char *s) {
    17	    17	    17	    15		char *c = s;
    18	    18	    18	    16		while (*c == ' ')
    19	    19	    19	    17			c += 1;
    20	    20	    20	    18		if ( *c != 'c' )
    21	    21	    21	    19			return 2;
    22	    22	    22	    20		c++;
    23	    23	    23	    21		if ( *c != 'd' )
    24	    24	    24	    22			return 2;
    25	    25	    25	    23		c++;
    26	    26	    26	    24		if ( *c != ' ' )
    27	    27	    27	    25			return 2;
    28	    28	    28	    26		while (*c == ' ')
    29	    29	    29	    27			c++;
    30	    30	    30	    28		char *d = c;
    31	    31	    31	    29		while (*c != ' ' && *c != '\0')
    32	    32	    32	    30			c++;
    33	    33	    33	    31		char helper = *c;
    34	    34	    34	    32		*c = '\0';
    35	    35	    35	    33		d = strdup(d);
    36	    36	    36	    34		*c = helper;
    37	    37	    37	    35		if ( strcmp(d,".") == 0 ) {
    38	    38	    38	    36			free(d);
    39	    39	    39	    37			return 0;
    40	    40	    40	    38		}
    41	    41	    41	    39		if ( strcmp(d,"..") == 0 ) {
    42	    42	    42	    40			free(d);
    43	    43	    43	    41			if ( strcmp(current_path,"/") == 0 )
    44	    44	    44	    42				return 1; // корневой диалог не имеет родителя
    45	    45	    45	    43			c = current_path + strlen(current_path);
    46	    46	    46	    44			while (*c != '/')
    47	    47	    47	    45				c--;
    48	    48	    48	    46			*c = '\0';
    49	    49	    49	    47			if ( strcmp(current_path,"") == 0 )
    50	    50	    50	    48				strcpy(current_path,"/");
    51	    51	    51	    49			return chdir(current_path);
    52	    52	    52	    50		}
    53	    53	    53	    51		if ( d[0] == '/' ) {
    54	    54	    54	    52			int k = chdir(d);
    55	    55	    55	    53			free(d);
    56	    56	    56	    54			return k;
    57	    57	    57	    55		} else {
    58	    58	    58	    56			strcat(current_path,"/");
    59	    59	    59	    57			strcat(current_path,d);
    60	    60	    60	    58			free(d);
    61	    61	    61	    59			return chdir(current_path);
    62	    62	    62	    60		}
    63	    63	    63	    61		return 0;
    64	    64	    64	    62	}
    65	    65	    65	    63	
    66	    66	    66	    64	void predobr(char *s);
    67	    67	    67	    65	
    68	    68	    68	    66	char **make_vector(char *s, int n) { 
    69	    69	    69	    67		char *c = s;
    70	    70	    70	    68	
    71	    71	    71	    69		int bracketsCounter = 0;
    72	    72	    72	    70		for (int i = 0; i < n;) {
    73	    73	    73	    71			if (*c == '(')
    74	    74	    74	    72				bracketsCounter += 1;
    75	    75	    75	    73			if (*c == ')')
    76	    76	    76	    74				bracketsCounter -= 1;
    77	    77	    77	    75			if (*c == '|' && bracketsCounter == 0)
    78	    78	    78	    76				i += 1;
    79	    79	    79	    77			c += 1;
    80	    80	    80	    78		}
    81	    81	    81	    79		if (*c == '|') c += 1;
    82	    82	    82	    80	
    83	    83	    83	    81		char *d = c;
    84	    84	    84	    82		// sort -r t.txt - 3 слова
    85	    85	    85	    83		int argc = 0;
    86	    86	    86	    84		while (*c == ' ')
    87	    87	    87	    85			c += 1; 
    88	    88	    88	    86		while (*c != '|' && *c != '\0') { 
    89	    89	    89	    87			while (*c != '|' && *c != '\0' && *c != ' ') {
    90	    90	    90	    88				c += 1;
    91	    91	    91	    89			}
    92	    92	    92	    90			while (*c == ' ')
    93	    93	    93	    91				c += 1;
    94	    94	    94	    92			argc += 1;
    95	    95	    95	    93		}
    96	    96	    96	    94	
    97	    97	    97	    95		char **argv = (char**)malloc(sizeof(char *) * (argc + 1));
    98	    98	    98	    96		argv[argc] = NULL;
    99	    99	    99	    97	
   100	   100	   100	    98		c = d;
   101	   101	   101	    99		for (int i = 0; i < argc; i += 1) {
   102	   102	   102	   100			while (*c == ' ')
   103	   103	   103	   101				c += 1;
   104	   104	   104	   102			d = c;
   105	   105	   105	   103			while (*c != '|' && *c != '\0' && *c != ' ') {
   106	   106	   106	   104				c += 1;
   107	   107	   107	   105			}
   108	   108	   108	   106			*c = '\0';
   109	   109	   109	   107			argv[i] = strdup(d);
   110	   110	   110	   108			c += 1;
   111	   111	   111	   109		}
   112	   112	   112	   110	
   113	   113	   113	   111		return argv;
   114	   114	   114	   112	}
   115	   115	   115	   113	
   116	   116	   116	   114	void br_implement(char *s, int n) {
   117	   117	   117	   115		char *c = s; 
   118	   118	   118	   116		int br_counter = 0;
   119	   119	   119	   117		for (int i = 0; i < n;) {
   120	   120	   120	   118			if (*c == '(')
   121	   121	   121	   119				br_counter += 1;
   122	   122	   122	   120			if (*c == ')')
   123	   123	   123	   121				br_counter -= 1;
   124	   124	   124	   122			if (*c == '|' && br_counter == 0)
   125	   125	   125	   123				i += 1;
   126	   126	   126	   124			c += 1;
   127	   127	   127	   125		}
   128	   128	   128	   126		if (*c == '|') c += 1;
   129	   129	   129	   127		while (*c == ' ')
   130	   130	   130	   128			c += 1; 
   131	   131	   131	   129		if ( *c == '(' ) {
   132	   132	   132	   130			char *d = c+1;
   133	   133	   133	   131			br_counter = 1;
   134	   134	   134	   132			while ( br_counter > 0 ) {
   135	   135	   135	   133				c += 1;
   136	   136	   136	   134				if (*c == '(')
   137	   137	   137	   135					br_counter += 1;
   138	   138	   138	   136				if (*c == ')')
   139	   139	   139	   137					br_counter -= 1;
   140	   140	   140	   138			}
   141	   141	   141	   139			*c = '\0';
   142	   142	   142	   140			predobr(d);
   143	   143	   143	   141			exit(0);
   144	   144	   144	   142		}
   145	   145	   145	   143	}
   146	   146	   146	   144	
   147	   147	   147	   145	char *get_input_file(char *s) {
   148	   148	   148	   146		int i = 0;
   149	   149	   149	   147		while (s[i] != '\0' && s[i] != '<')
   150	   150	   150	   148			i += 1;
   151	   151	   151	   149		if (s[i] == '\0')
   152	   152	   152	   150			return NULL;
   153	   153	   153	   151		s[i] = ' ';
   154	   154	   154	   152		while (s[i] == ' ')
   155	   155	   155	   153			i += 1;
   156	   156	   156	   154		int j = i;
   157	   157	   157	   155		while (s[i] != ' ' && s[i] != '\0' && s[i] != '|')
   158	   158	   158	   156			i += 1;
   159	   159	   159	   157		char helper = s[i];
   160	   160	   160	   158		s[i] = '\0';
   161	   161	   161	   159		char *c = strdup(s + j);
   162	   162	   162	   160		s[i] = helper;			
   163	   163	   163	   161	
   164	   164	   164	   162		while (j < i) {
   165	   165	   165	   163			s[j] = ' ';
   166	   166	   166	   164			j += 1;
   167	   167	   167	   165		}
   168	   168	   168	   166		return c;
   169	   169	   169	   167	}
   170	   170	   170	   168	
   171	   171	   171	   169	char *get_output_file(char *s, int *append) {
   172	   172	   172	   170		int i = 0;
   173	   173	   173	   171		while (s[i] != '\0' && s[i] != '>')
   174	   174	   174	   172			i += 1;
   175	   175	   175	   173		if (s[i] == '\0')
   176	   176	   176	   174			return NULL;
   177	   177	   177	   175		s[i] = ' ';
   178	   178	   178	   176		i += 1;
   179	   179	   179	   177		if (s[i] == '>') {
   180	   180	   180	   178			s[i] = ' ';	 // затираем пробелом
   181	   181	   181	   179			*append = 1; // если двойная > => дозапись файла
   182	   182	   182	   180		}
   183	   183	   183	   181		while (s[i] == ' ')
   184	   184	   184	   182			i += 1;
   185	   185	   185	   183		int j = i;
   186	   186	   186	   184		while (s[i] != ' ' && s[i] != '\0' && s[i] != '|')
   187	   187	   187	   185			i += 1;
   188	   188	   188	   186	
   189	   189	   189	   187		char helper = s[i];
   190	   190	   190	   188		s[i] = '\0';
   191	   191	   191	   189		char *c = strdup(s + j);
   192	   192	   192	   190		s[i] = helper;
   193	   193	   193	   191	
   194	   194	   194	   192		while (j < i) {
   195	   195	   195	   193			s[j] = ' ';
   196	   196	   196	   194			j += 1;
   197	   197	   197	   195		}
   198	   198	   198	   196	
   199	   199	   199	   197		return c;
   200	   200	   200	   198	}
   201	   201	   201	   199	
   202	   202	   202	   200	char *input_str() {
   203	   203	   203	   201		char *ptr = (char *)malloc(100);
   204	   204	   204	   202		char c;
   205	   205	   205	   203		int i = 0;
   206	   206	   206	   204		c = getchar();
   207	   207	   207	   205		while ((c != '\n') && (c != EOF)) {
   208	   208	   208	   206			ptr[i] = c;
   209	   209	   209	   207			c = getchar();
   210	   210	   210	   208			i++;
   211	   211	   211	   209		}
   212	   212	   212	   210		ptr[i] = '\0';
   213	   213	   213	   211		return ptr;
   214	   214	   214	   212	}
   215	   215	   215	   213	
   216	   216	   216	   214	int implementation(char *s){
   217	   217	   217	   215	
   218	   218	   218	   216		char *fInput = get_input_file(s);
   219	   219	   219	   217		int append = 0;
   220	   220	   220	   218		char *fOutput = get_output_file(s, &append);
   221	   221	   221	   219	
   222	   222	   222	   220	
   223	   223	   223	   221		int n = 1;
   224	   224	   224	   222		char *c = s;
   225	   225	   225	   223		int bracketsCounter = 0;
   226	   226	   226	   224		while (*c != '\0') {
   227	   227	   227	   225			if (*c == '(')
   228	   228	   228	   226				bracketsCounter += 1;
   229	   229	   229	   227			if (*c == ')')
   230	   230	   230	   228				bracketsCounter -= 1;
   231	   231	   231	   229			if (*c == '|' && bracketsCounter == 0)
   232	   232	   232	   230				n += 1;
   233	   233	   233	   231			c += 1;
   234	   234	   234	   232		}
   235	   235	   235	   233	
   236	   236	   236	   234		if ( n == 1 ) {
   237	   237	   237	   235			int k = MayBeCD(s);
   238	   238	   238	   236			if (k == 0)
   239	   239	   239	   237				return 0;
   240	   240	   240	   238			if (k == 1)
   241	   241	   241	   239				return 1;
   242	   242	   242	   240		}
   243	   243	   243	   241		
   244	   244	   244	   242		int *sons = (int *)malloc(sizeof(int) * n);
   245	   245	   245	   243	
   246	   246	   246	   244		int fd[2], prevpipe;
   247	   247	   247	   245	
   248	   248	   248	   246		for (int i = 0; i < n; i += 1) {
   249	   249	   249	   247			if (i != n - 1)
   250	   250	   250	   248				pipe(fd);
   251	   251	   251	   249			if ((sons[i] = fork()) == 0) {
   252	   252	   252	   250				/* ВВОД */
   253	   253	   253	   251				if (i != 0) {
   254	   254	   254	   252					dup2(prevpipe, 0);
   255	   255	   255	   253				} 
   256	   256	   256	   254	
   257	   257	   257	   255				else {
   258	   258	   258	   256					if (fInput != NULL) {
   259	   259	   259	   257						int j = open(fInput, O_RDONLY);
   260	   260	   260	   258						if (j == -1) {
   261	   261	   261	   259							j = open("/dev/null", O_RDONLY);
   262	   262	   262	   260						}
   263	   263	   263	   261						dup2(j, 0);
   264	   264	   264	   262					}
   265	   265	   265	   263				}
   266	   266	   266	   264	
   267	   267	   267	   265				/* ВЫВОД */
   268	   268	   268	   266				if (i != n - 1) {
   269	   269	   269	   267					dup2(fd[1], 1);
   270	   270	   270	   268				}
   271	   271	   271	   269				else{
   272	   272	   272	   270					if (fOutput != NULL) {
   273	   273	   273	   271						int j;
   274	   274	   274	   272						if (append == 0)
   275	   275	   275	   273							j = open(fOutput, O_WRONLY | O_CREAT | O_TRUNC, 0777);
   276	   276	   276	   274						else 
   277	   277	   277	   275							j = open(fOutput, O_WRONLY | O_CREAT | O_APPEND, 0777);
   278	   278	   278	   276						dup2(j, 1);
   279	   279	   279	   277					}
   280	   280	   280	   278				}
   281	   281	   281	   279				/**/
   282	   282	   282	   280				
   283	   283	   283	   281				br_implement(s,i);
   284	   284	   284	   282				char **argv = make_vector(s, i);
   285	   285	   285	   283				execvp(argv[0], argv); // -1 не нашел такой команды
   286	   286	   286	   284				printf("Такой команды не существует: %s\n", argv[0]); // только при -1
   287	   287	   287	   285				exit(1);
   288	   288	   288	   286			}
   289	   289	   289	   287			if (n != 1) { // если в конвейере 1 программа - не делаем pipe
   290	   290	   290	   288				if (i == 0) { // 1й сын
   291	   291	   291	   289					prevpipe = fd[0];
   292	   292	   292	   290					close(fd[1]); // закрываем только вывод
   293	   293	   293	   291				}
   294	   294	   294	   292				else if (i == n - 1) { // последний сын
   295	   295	   295	   293					close(prevpipe); // закрываем только ввод
   296	   296	   296	   294				}
   297	   297	   297	   295				else {
   298	   298	   298	   296					close(prevpipe); // закрываем ввод
   299	   299	   299	   297					prevpipe = fd[0];
   300	   300	   300	   298					close(fd[1]); // закрываем вывод
   301	   301	   301	   299				}
   302	   302	   302	   300			}
   303	   303	   303	   301		}
   304	   304	   304	   302	
   305	   305	   305	   303		int k;
   306	   306	   306	   304		for (int i = 0; i < n; i += 1)
   307	   307	   307	   305			waitpid(sons[i], &k, 0); // 0 - выполняйся так, как логичнее (флаги)
   308	   308	   308	   306		free(sons);
   309	   309	   309	   307		free(fInput);
   310	   310	   310	   308		free(fOutput);
   311	   311	   311	   309		return k;
   312	   312	   312	   310	}
   313	   313	   313	   311	
   314	   314	   314	   312	void choose_implementation(char *s){
   315	   315	   315	   313		printf("Получено: %s\n", s);
   316	   316	   316	   314		char *c=s, helper;
   317	   317	   317	   315		int br_count = 0;
   318	   318	   318	   316		while(*c == ' '){
   319	   319	   319	   317			br_count++;
   320	   320	   320	   318		}
   321	   321	   321	   319		while(*c != '\0'){
   322	   322	   322	   320			while(*c != '\0'){
   323	   323	   323	   321				if(*c == '('){
   324	   324	   324	   322					br_count++;
   325	   325	   325	   323				}
   326	   326	   326	   324				if(*c == ')'){
   327	   327	   327	   325					br_count--;
   328	   328	   328	   326				}
   329	   329	   329	   327				if(br_count == 0 && *c == '&' && *(c+1) == '&'){
   330	   330	   330	   328					break;
   331	   331	   331	   329				}
   332	   332	   332	   330				if(br_count == 0 && *c == '|' && *(c+1) == '&'){
   333	   333	   333	   331					break;
   334	   334	   334	   332				}
   335	   335	   335	   333				c++;
   336	   336	   336	   334			}
   337	   337	   337	   335			helper = *c;
   338	   338	   338	   336			*c = '\0';
   339	   339	   339	   337			printf("Выполнение %s\n", s);// ps && (cd ..; ps)
   340	   340	   340	   338			int status = implementation(s);
   341	   341	   341	   339			printf("Выполнил: %s\n", s);
   342	   342	   342	   340			// обработка выполнения && и ||
   343	   343	   343	   341			*c = helper;
   344	   344	   344	   342			if (status != 0 && helper == '&')
   345	   345	   345	   343				break; // && выполняется при успешном выполнении предыдущей команды
   346	   346	   346	   344			if (status == 0 && helper == '|')
   347	   347	   347	   345				break;
   348	   348	   348	   346			if (*c == '\0')
   349	   349	   349	   347				break;
   350	   350	   350	   348			c += 2;
   351	   351	   351	   349			while (*c == ' ')
   352	   352	   352	   350				c += 1;
   353	   353	   353	   351			s = c;
   354	   354	   354	   352		}
   355	   355	   355	   353		printf("Отдача: %s\n", s);
   356	   356	   356	   354		return;
   357	   357	   357	   355	}
   358	   358	   358	   356	
   359	   359	   359	   357	void predobr(char *s){
   360	   360	   360	   358		char *c = s;// com1 && (com2; com3)
   361	   361	   361	   359		while(*c == ' '){
   362	   362	   362	   360			c ++;
   363	   363	   363	   361		}
   364	   364	   364	   362		int br_count = 0;
   365	   365	   365	   363		while(*c != '\0'){
   366	   366	   366	   364			while(*c != '\0'){
   367	   367	   367	   365				if(*c == '('){
   368	   368	   368	   366					br_count++;
   369	   369	   369	   367				}
   370	   370	   370	   368				if(*c == ')'){
   371	   371	   371	   369					br_count--;
   372	   372	   372	   370				}
   373	   373	   373	   371				if(*c == ';' && br_count == 0){
   374	   374	   374	   372					break;
   375	   375	   375	   373				}
   376	   376	   376	   374				if (*c == '&' && *(c + 1) != '&' && c - s != 0 && *(c - 1) != '&' && br_count == 0)
   377	   377	   377	   375					break;
   378	   378	   378	   376				c++;
   379	   379	   379	   377			}
   380	   380	   380	   378	
   381	   381	   381	   379			char helper = *c;
   382	   382	   382	   380			*c = '\0';
   383	   383	   383	   381			if(helper == ';' || helper == '\0'){
   384	   384	   384	   382				// printf("выполнение команды");
   385	   385	   385	   383				choose_implementation(s);
   386	   386	   386	   384			}
   387	   387	   387	   385			else{// фоновый режим
   388	   388	   388	   386				// printf("фоновый режим\n");
   389	   389	   389	   387				int pid1 = fork();
   390	   390	   390	   388				if(pid1 == 0){
   391	   391	   391	   389					if(fork() == 0){
   392	   392	   392	   390						signal(SIGINT, SIG_IGN);
   393	   393	   393	   391						int f1 = open("/dev/null", O_RDONLY);
   394	   394	   394	   392						dup2(f1, 0);
   395	   395	   395	   393						close(f1);
   396	   396	   396	   394						choose_implementation(s);
   397	   397	   397	   395						exit(0);
   398	   398	   398	   396					}
   399	   399	   399	   397					exit(0); // делаем внука независимымs
   400	   400	   400	   398				}
   401	   401	   401	   399				waitpid(pid1, NULL, 0);
   402	   402	   402	   400				
   403	   403	   403	   401			}
   404	   404	   404	   402			*c = helper;
   405	   405	   405	   403			if(*c == '\0'){
   406	   406	   406	   404				break;
   407	   407	   407	   405			}
   408	   408	   408	   406			c++;
   409	   409	   409	   407			while(*c == ' '){
   410	   410	   410	   408				c++;
   411	   411	   411	   409			}
   412	   412	   412	   410			s = c;
   413	   413	   413	   411		}
   414	   414	   414	   412		return;
   415	   415	   415	   413	}
   416	   416	   416	   414	
   417	   417	   417	   415	int main(){
   418	   418	   418	   416		while(1){
   419	   419	   419	   417			getcwd(current_path, 1000);
   420	   420	   420	   418			printf("%s %%", current_path);
   421	   421	   421	   419			char *s = input_str();
   422	   422	   422	   420			if ( strcmp(s,"exit") == 0 ) {
   423	   423	   423	   421				free(s);
   424	   424	   424	   422				return 0;
   425	   425	   425	   423			}
   426	   426	   426	   424			predobr(s);
   427	   427	   427	   425		}
   428	   428	   428	   426	}Выполнил: ls -l|cat -n 1.c
   429	   429	   429	Отдача: ls -l|cat -n 1.c